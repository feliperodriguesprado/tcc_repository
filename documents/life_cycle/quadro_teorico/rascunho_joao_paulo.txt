JAVA EE
O Java EE (Java Enterprise Edition) consiste de uma série de especificações bem detalhadas, fornecendo toda uma infraestrutura para o desenvolvedor utilizar. Os serviços dessa infraestrutura compreendem web services, gerenciamento de threads, gerenciamento de conexões HTTP, gerenciamento da sessão web, etc. A Sun Corporation criou essa especificação para que diminuir os custos dos projetos que utilizam Java, pois utilizando Java EE não teria a necessidade de se desenvolver novamente as funcionalidades citadas anteriormente. Porém Java EE é apenas um conjunto de especificações, sendo necessário utilizar uma implementação dessas especificações, nessa pesquisa utilizou a implementação padrão fornecida pela Oracle, o GlassFish Server Open Source (CAELUM, 2015).

CAELUM. Apostila Java para Desenvolvimento Web. 2015. Disponível em https://www.caelum.com.br/apostila-java-web/. Acesso em 08 de agosto, 2015.

JAVA WEB

Trilha do Aprendizado do Java EE e Java Web

Uma aplicação Java Web gera páginas Web interativas, que contêm vários tipos de linguagem de marcação (HTML, XML, etc.) e conteúdo dinâmico. Normalmente é composto por componentes Web, servlets e JavaBeans para modificar e armazenar dados temporariamente, interagir com bancos de dados e Web services e processar o conteúdo como resposta às solicitações do cliente (NETBEANS, 2015). Utilizar-se dessa tecnologia levaria a ter uma grande economia de tempo e recursos de desenvolvimento, pois não seria necessário desenvolver a aplicação preocupando-se com os dispositivos clientes a ser utilizados.

NETBEANS. Trilha do Aprendizado do Java EE e Java Web. 2015. Disponível em https://netbeans.org/kb/trails/java-ee_pt_BR.html. Acesso em 12 de agosto, 2015.

EJB

Enterprise JavaBeans (EJB) é a arquitetura de componentes do lado do servidor para a plataforma Java Enterprise Edition (Java EE). Nela são encapsulado as lógicas de negócio de uma aplicação, ou seja, os objetivos da aplicação são implementados nessa parte do projeto. Utilizá-la permite o desenvolvimento rápido e simplificado de aplicativos transacionais, distribuídos, seguros e portáteis baseados na tecnologia Java (ORACLE, 2015).

ORACLE. Apostila Java para Desenvolvimento Web. 2015. Disponível em http://www.oracle.com/technetwork/java/javaee/ejb/index.html. Acesso em 10 de agosto, 2015.


CDI

A Injeção de Dependência e Contextos (CDI), especificada por JSR-299, é parte integrante do Java EE e fornece uma arquitetura que 
permite aos componentes do Java EE, como os servlets, enterprise beans e JavaBeans, existirem dentro do ciclo de vida de uma aplicação 
com escopos bem definidos. O CDI é uma API para injeção de dependências e contextos (NETBEANS, 2015). A injeção de dependências é executada através do 
uso de anotações, uma das mais conhecidas é a anotação @Inject na qual podemos injetar contextos em outro local do código.


NETBEANS. Trabalhando com Injeção e Qualificadores no CDI. 2015. Disponível em https://netbeans.org/kb/docs/javaee/cdi-inject_pt_BR.html. Acesso em 09 de agosto, 2015.



 
MANIFEST.MF

A única diferença entre um bundle e um arquivo tradicional é uma pequena quantidade de metadados adicionado ao arquivo manifest.mf. Então, caso deseje-se usar um bundle JAR fora de um contêiner OSGi, não haverá nenhum problema (FERNANDES, 2009).
De acordo com Vogel (2015) os principais metadados e suas respectivas características são apresentados a seguir:

Bundle-Name - Nome ou breve descrição do bundle.
Bundle-SymbolicName	- O identificador único do bundle.
Bundle-Version - Define a versão do bundle e deve ser incrementado sempre que uma nova versão é publicada.
Bundle-Activator - Define uma classe opcional activator que implementa a interface BundleActivator. Uma instância dessa classe é criada quando o budle é ativado e seus métodos start() e stop() são chamados sempre que o módulo é iniciado ou parado. Essa classe activador pode ser utilizada para configurar o bundle durante a inicialização ou realizar alguma operação antes dele ser parado.
Bundle-RequiredExecutionEnvironment - Especifiqua qual versão Java é necessária para executar o bundle. Se esta exigência não for cumprida, o framework OSGi não inicializa o budle.
Bundle-ActivationPolicy - Configuração que permite definir se o framework OSGi irá inicializar os bundles de forma Lazy ou não, se ativar a opção de Lazy o bundle só será ativado caso alguma classe, interface ou serviço necessite.
Bundle-ClassPath - O Bundle-ClassPath especifica o diretório de onde será carregado as classes do bundle. O padrão é '' pois permite que classes possam ser carregadas a partir da raiz do pacote.

Web-ContextPath - Caminho que especifica qual o caminho da URL que o cliente deverá usar para acessar os serviços do bundle. Ressaltando que essa tag deverá estar presente em arquivos de pacote do tipo WAR.
Export-EJB: Define os EJBs que suas funcionalidades vão ser disponibilizadas via serviços do OSGi. Onde quando se utiliza o valor "ALL" se exporta como serviços todos os EJBs presentes, usa-se "NONE" para não disponibilizar nenhum e havendo a necessidade de disponibilizar apenas alguns EJB como serviços, coloca-se o Bundle-SymbolicName separado por vírgulas, caso haja mais de um EJB, como o exemplo a seguir: Export-EJB: com.acme.FooEJB, com.acme.BarEJB
import-package: Lista dos pacotes requeridos pelo módulo para o seu funcionamento com a sua devida versão especificada.
export-package: Lista dos pacotes visíveis e utilizáveis pelos módulos externos.
----------------------------------------------------------------------------------------------------------------------------------------------------------------



VOGEL, Lars. OSGi Modularity - Tutorial. 2015. Disponível em
http://www.vogella.com/tutorials/OSGi/article.html. Acesso em 18 de abril, 2015.

MODULARIZAÇÃO
Para se determinar o quão independentes são os módulos em um sistema, utiliza-se a verificação de dois critérios: coesão e acoplamento.


O quanto os módulos são independentes é determinado levando em consideração dois critérios: coesão e acoplamento. A coesão é a relação existente entre as responsabilidades e as unidades dos módulos. Onde um módulo coeso tem responsabilidades e propósitos claros e bem definidos. O acoplamento é o grau em que um módulo depende de outros, com isso o acoplamento surge em função do relacionamento existente entre os módulos e é caracterizado pelo uso se serviços entre eles (STAA, 2000).

Em engenharia de software, acoplamento ou dependência é o grau em que um módulo depende de outros módulos de programação.

Resultado de imagem para o que é coesão e acoplamento
Coesão e Acoplamento são princípios de engenharia de software muito utilizados. Quando queremos ter uma arquitetura madura e sustentável, temos que levar em conta estes dois princípios, pois cada um deles tem um propósito específico que visa melhorar o design do software




Leia mais em: Artigo Java Magazine 77 - Coesão e Acoplamento em Sistemas Orientados a Objetos http://www.devmedia.com.br/artigo-java-magazine-77-coesao-e-acoplamento-em-sistemas-orientados-a-objetos/16167#ixzz3mhROeGMh